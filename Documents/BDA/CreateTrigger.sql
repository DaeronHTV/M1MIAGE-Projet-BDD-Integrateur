DROP TRIGGER updatePersonnelHistorique;
DROP TRIGGER createResidentHisto;
DROP TRIGGER mortResidentRdv;
DROP TRIGGER deplacerPersonnel;
DROP TRIGGER CRExistAlready;

/*
 * TRIGGER SE DECLENCHANT LORSQU'UN PERSONNEL EST DEPLACE DANS UNE UNITE CONFINE
 * ALORS QU'IL TRAVAIL DANS UNE UNITE NORMAL
 */
CREATE TRIGGER deplacerPersonnel
BEFORE INSERT ON AFFECTATION FOR EACH ROW
DECLARE etatNewUnite VARCHAR2(20); nbUnite NUMBER;
cannot_deplace_personnel EXCEPTION;
PRAGMA exception_init(cannot_deplace_personnel, -1000);
BEGIN
    SELECT ETATUNITE INTO etatNewUnite FROM UNITE WHERE IDUNITE = :NEW.IDUNITE;
    IF(etatNewUnite = 'CONTAGIEUSE') THEN
        SELECT count(*) INTO nbUnite FROM UNITE
        INNER JOIN AFFECTATION ON AFFECTATION.IDUNITE = UNITE.IDUNITE
        WHERE ETATUNITE IN ('OUVERTE', 'DE JOUR', 'FERMEE');
    ELSE
        SELECT count(*) INTO nbUnite FROM UNITE
        INNER JOIN AFFECTATION ON AFFECTATION.IDUNITE = UNITE.IDUNITE
        WHERE ETATUNITE IN ('CONTAGIEUSE');
    END IF;
    IF(nbUnite != 0) THEN
        RAISE cannot_deplace_personnel;
    END IF;
    EXCEPTION
        WHEN cannot_deplace_personnel THEN
            dbms_output.put_line('message test');
            ROLLBACK;
END;

/*
 * TRIGGER SE DECLENCHANT LORSQU'UN RESIDENT EST DECLARE DECEDE
 * TOUT SES RENDEZVOUS SONT ANNULES
 */
CREATE TRIGGER mortResidentRdv
AFTER UPDATE ON RESIDENT FOR EACH ROW
BEGIN
    IF(:NEW.STATUTRESIDENT = 'ANCIENRESIDENT') THEN
        UPDATE RENDEZVOUS
        SET ETATRENDEZVOUS = 'ANNULE'
        WHERE ETATRENDEZVOUS IN ('PROGRAMME', 'VALIDE') AND IDRESIDENT = :NEW.IDRESIDENT;
    END IF;
END;

/*
 * TRIGGER SE DECLENCHANT LORSQU'ON INSERE UN NOUVEAU RESIDENT
 * ON AJOUTE LE PERSONNEL ASSOCIE AINSI QUE LA DATE DE DEBUT
 * DANS L'HISTORIQUE
 */
 CREATE TRIGGER createResidentHisto
 AFTER INSERT ON RESIDENT FOR EACH ROW
 BEGIN
    INSERT INTO PERSONNELRESIDENT VALUES (SYS_GUID(), :NEW.IDRESIDENT, :NEW.IDPERSONNEL, CURRENT_TIMESTAMP, null);
 END;

/*
 * TRIGGER SE DECLENCHANT LORSQUE LE PERSONNEL EN CHARGE D'UN RESIDENT CHANGE
 * ON AJOUTE LA DATE DE FIN A L'ANCIEN PERSONNEL ET ON AJOUTE LA DATE DE DEBUT
 * AU NOUVEAU
 */
CREATE TRIGGER updatePersonnelHistorique
AFTER UPDATE ON RESIDENT FOR EACH ROW
BEGIN
    IF(:NEW.IDPERSONNEL != :OLD.IDPERSONNEL) THEN
        --ON MET A JOUR LA DATEFIN DE L'ANCIEN PERSONNEL
        UPDATE PERSONNELRESIDENT
        SET DATEFIN = CURRENT_TIMESTAMP
        WHERE IDPERSONNEL = :OLD.IDPERSONNEL AND IDRESIDENT = :OLD.IDRESIDENT;
        --ON INSERE LE NOUVEAU PERSONNEL DANS L'HISTORIQUE
         INSERT INTO PERSONNELRESIDENT VALUES (SYS_GUID(),:OLD.IDRESIDENT, :NEW.IDPERSONNEL, CURRENT_TIMESTAMP, null);
    END IF;
END;

/*
 * Permet d'eviter de dupliquer des lignes déjà existantes dans 
 * dans la table CONTACTRESIDENT
 */
CREATE TRIGGER CRExistAlready
AFTER INSERT ON CONTACTRESIDENT FOR EACH ROW
DECLARE alreadyExist EXCEPTION;
PRAGMA exception_init(alreadyExist, -1001);
BEGIN
    IF(:NEW.IDCONTACT = :OLD.IDCONTACT) THEN
        IF(:NEW.IDRESIDENT = :OLD.IDRESIDENT) THEN
            RAISE alreadyExist;
        END IF;
    END IF;
    EXCEPTION
        WHEN alreadyExist THEN
            dbms_output.put_line('La ligne existe déjà');
            ROLLBACK;
END;